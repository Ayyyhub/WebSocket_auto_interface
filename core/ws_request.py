import json
from utils.logger import logger
import time
from datetime import datetime

from Message.dispatcher import (
    MessageDispatcher,
    NonJsonMessageError,
    ResponseTimeoutError,
)

_dispatchers = {}
_seq_counters = {}      # 全局字典：为每个WebSocket客户端维护独立的id自增序列

# 从消息层拿数据
def _get_dispatcher(ws_client):
    if ws_client is None:
        raise ValueError("ws_client 不能为空")
    key = id(ws_client)
    if key not in _dispatchers:
        _dispatchers[key] = MessageDispatcher(ws_client)
    return _dispatchers[key]


""" 封装具体的【发送请求--接收响应并断言】的处理 """
# req: 请求字典，通常包含 func 、 args 、 id ，用于告诉后端要调用哪个接口以及参数
# desc: 本次请求的文本描述，用于日志定位具体接口
# expect_success: 是否要求响应里 success == True ，为真则不满足时抛异常
# expect_ret: 期望的 ret 内容，不为 None 时会断言等值，不等则抛异常
def ws_send_and_wait(req, desc, expect_success=True, expect_ret=None, max_none_retry=3, timeout_per_recv=5, ws_client=None, continue_on_error=False):
    result_stats = []
    dispatcher = _get_dispatcher(ws_client)
    req_id = str(req.get("id"))
    ws_client.send(req)
    start_time = time.time()

    # 返回三元组，JSON解析的结果-parsed_response，出现NONE的次数-none_count，以及耗时-elapsed
    try:
        parsed_response, none_count, elapsed = dispatcher.wait_for_response(
            req_id, desc, max_none_retry=max_none_retry, timeout_per_recv=timeout_per_recv
        )
    except ResponseTimeoutError as e:
        logger.info(f"{desc}连续{max_none_retry}次无响应")
        fail_reason = f"连续{max_none_retry}次无响应"
        result_stats.append({
            "desc": desc,
            "none_count": e.none_count,
            "elapsed": time.time() - start_time,
            "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "success": False,
            "fail_reason": fail_reason,
            "req": json.dumps(req, ensure_ascii=False),
            "resp": None
        })
        if continue_on_error:
            logger.error(f"{desc}连续{max_none_retry}次无响应 (已忽略错误)")
            return None
        raise AssertionError(f"{desc}连续{max_none_retry}次无响应")
    except NonJsonMessageError as e:
        logger.info(f"{desc}收到非json响应: {e.raw_message}")
        fail_reason = "非json响应"
        result_stats.append({
            "desc": desc,
            "none_count": 0,
            "elapsed": time.time() - start_time,
            "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "success": False,
            "fail_reason": fail_reason,
            "req": json.dumps(req, ensure_ascii=False),
            "resp": e.raw_message
        })
        if continue_on_error:
            logger.error(f"{desc}收到非json响应 (已忽略错误)")
            return None
        raise AssertionError(f"{desc}收到非json响应")
    print("\n")
    logger.info(f"{desc} 请求: {req} \n响应: {parsed_response}")

    # ret 为空数组时,断言宽容通过
    if parsed_response == [] or (isinstance(parsed_response, dict) and parsed_response.get("ret") == []):
        logger.info(f"{desc} 响应为空数组[]，已跳过断言")
        result_stats.append({
            "desc": desc,
            "none_count": none_count,
            "elapsed": elapsed,
            "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "success": True,
            "fail_reason": "响应为空数组，跳过断言",
            "req": json.dumps(req, ensure_ascii=False),
            "recv_req": json.dumps(parsed_response, ensure_ascii=False)
        })
        return parsed_response

    # expect_success为真且success != True
    if expect_success and isinstance(parsed_response, dict):
        if parsed_response.get("success") != True:
            fail_reason = f"success!=True, error: {parsed_response.get('error', '')}"
            result_stats.append({
                "desc": desc,
                "none_count": none_count,
                "elapsed": elapsed,
                "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "success": False,
                "fail_reason": fail_reason,
                "req": json.dumps(req, ensure_ascii=False),
                "recv_req": json.dumps(parsed_response, ensure_ascii=False)
            })
            if continue_on_error:
                logger.error(f"{desc} 失败: {parsed_response} (已忽略错误)")
                return parsed_response
            raise AssertionError(f"{desc} 失败: {parsed_response}")

    # expect_ret不为None且ret != expect_ret
    if expect_ret is not None and isinstance(parsed_response, dict):
        if parsed_response.get("ret") != expect_ret:
            fail_reason = f"ret不符, ret: {parsed_response.get('ret', '')}"
            result_stats.append({
                "desc": desc,
                "none_count": none_count,
                "elapsed": elapsed,
                "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "success": False,
                "fail_reason": fail_reason,
                "req": json.dumps(req, ensure_ascii=False),
                "recv_req": json.dumps(parsed_response, ensure_ascii=False)
            })
            if continue_on_error:
                logger.error(f"{desc} 返回ret不符: {parsed_response} (已忽略错误)")
                return parsed_response
            raise AssertionError(f"{desc} 返回ret不符: {parsed_response}")


    #======  正常通过：计算耗时、记录成功统计  =======
    logger.info(f"{desc}响应成功，总耗时: {elapsed:.2f}s，None重试: {none_count}次")
    result_stats.append({
        "desc": desc,
        "none_count": none_count,
        "elapsed": elapsed,
        "timestamp": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        "success": True,
        "fail_reason": "",
        "req": json.dumps(req, ensure_ascii=False),
        "recv_req": json.dumps(parsed_response, ensure_ascii=False)
    })
    time.sleep(0.3)
    return parsed_response





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































